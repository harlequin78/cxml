<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>Closure XML</title>
    <style type="text/css">
      body {
        color: #000000;
        background-color: #ffffff;
        margin-bottom: 10%;
        padding-left: 30px;
      }
      h1,h2,h3 {
        margin-left: -30px;
      }
      pre {
        background-color: #eeeeee;
        border: solid 1px #d0d0d0;
        padding: 1em;
        margin-right: 10%;
      }
      .def {
        background-color: #ddddff;
        font-weight: bold;
      }
      .nomargin {
        margin-bottom: 0;
        margin-top: 0;
      }
    </style>
  </head>
  <body>
    <h1>Closure XML Parser</h1>

    <p>An XML parser written in Common Lisp.</p>

    <p>
      Closure XML was written by <a
      href="http://www.stud.uni-karlsruhe.de/~unk6/">Gilbert Baumann</a>
      (unk6 at rz.uni-karlsruhe.de) as part of the Closure web
      browser.<br/>
      Contributions to the parser by
    </p>
    <ul>
      <li>
        Henrik Motakef (hmot at henrik-motakef.de)<br/>
        (SAX layer; namespace support)
      </li>
      <li>
        David Lichteblau at knowledgeTools (david at knowledgetools.de)<br/>
        (conversion into an independent package; DOM bug fixing; validation)
      </li>
    </ul>

    <p>
      Mailing list <a
      href="http://common-lisp.net/mailman/listinfo/cxml-devel">cxml-devel</a>
      is hosted on common-lisp.net.
    </p>

    <h2>Download</h2>
    <p>
      Get a <a href="http://www.common-lisp.net/project/cxml/download/">tarball</a>.
    </p>
    <p>
      David's tla archive is at <a
      href="http://common-lisp.net/project/cxml/david@knowledgetools.de--cxml/">http://www.common-lisp.net/project/cxml/david@knowledgetools.de--cxml/</a>.
      (Brief tla usage instructions: Unpack the cxml tarball.&amp;nbsp;
      Enter <tt>tla register-archive URL</tt> to turn it into a working
      copy.&amp;nbsp; <tt>tla update</tt> is similar to <tt>cvs up</tt>.)
    </p>

    <h1>Contents</h1>
    <ul>
      <li><a href="#changes">Recent Changes</a></li>
      <li><a href="#modules">CXML Modules</a></li>
      <li><a href="#installation">Installation</a></li>
      <li><a href="#tests">Tests</a></li>
      <li><a href="#todo">To Do</a></li>
      <li>
        <a href="#using">Using CXML</a>
        <ul>
          <li><a href="#quickstart">Quick-Start Example</a></li>
          <li><a href="#parser">Parsing and Validating</a></li>
          <li><a href="#serialization">Serialization</a></li>
          <li><a href="#misc">Miscellaneous Utility Functions</a></li>
          <li><a href="#xmls">XMLS Compatibility</a></li>
          <li><a href="#rods">Dealing with Rods</a></li>
        </ul>
      </li>
      <li><a href="#sax">SAX Interface</a></li>
      <li><a href="#dom">DOM Notes</a></li>
    </ul>

    <a name="changes"/>
    <h2>Recent Changes</h2>
    <p class="nomargin"><tt>patch-306</tt> (2004-09-03)</p>
    <ul class="nomargin">
      <li>Event-based serialization which does not require DOM documents</li>
      <li>XMLS compatiblity</li>
      <li>minor bugfixes (thread safety; should work on clisp again)</li>
    </ul>
    <p class="nomargin"><tt>patch-279</tt> (2004-05-11)</p>
    <ul class="nomargin">
      <li>Validation</li>
      <li>bugfixes; XHTML DTD parses again; corrected SAX entity handling</li>
    </ul>
    <p class="nomargin"><tt>patch-204</tt> (buggy release)</p>
    <ul class="nomargin">
      <li>Renamed package <tt>XML</tt> to <tt>CXML</tt>.</li>
      <li>The unparse functions support non-canonical output now.</li>
    </ul>
    <p class="nomargin"><tt>patch-191</tt> (2004-03-18)</p>
    <ul class="nomargin">
      <li>Initial release.</li>
    </ul>

    <a name="modules"/>
    <h2>CXML Modules</h2>
    <p>CXML provides three packages:</p>
    <ul>
      <li>
        <tt>RUNES</tt>, a portable implementation of Unicode strings.
      </li>
      <li>
        <tt>CXML</tt>, a namespace-aware validating SAX parser
        implementing the <a
        href="http://www.w3.org/TR/2000/REC-xml-20001006">XML 1.0
        specification</a>.
      </li> 
      <li>
        <tt>DOM</tt>, an implementation of the <a
        href="http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html">DOM
        Level 1 Core</a> interfaces.
      </li>
    </ul>

    <a name="installation"/>
    <h2>Installation</h2>
    <p>
      CXML is written in Common Lisp and should be portable to all
      Common Lisp implementations.&amp;nbsp; Currently assumed to work are
      ACL, SBCL, CMUCL, and CLISP, though development is done on
      ACL.&amp;nbsp; (CLISP needs some <tt>-E</tt> option teaching it to
      accept non-ASCII source files.)
    </p>

    <p>
      <a href="http://www.cliki.net/asdf">ASDF</a> is used for
      compilation.  The following instructions assume that ASDF has
      already been loaded.
    </p>

    <p>
      <b>Configuration (optional).</b>
      CXML has full Unicode code support -- even on Lisps without
      Unicode strings.  On non-unicode aware Lisps, <tt>DOMString</tt>
      is implemented as an array of character codes.  If your Lisp
      supports 16 bit characters natively, you can enable feature
      <tt>RUNE-IS-CHARACTER</tt> to select an alternative
      <tt>DOMString</tt> implementatation, which uses real characters
      instead of characters codes.
    </p>
    <pre>* (pushnew :rune-is-character *features*)</pre>

    <p>
      <b>Compiling and loading CXML.</b>
      Register the .asd file, e.g. by symlinking it:
    </p>
    <pre>$ ln -sf `pwd`/cxms.asd /path/to/your/registry</pre>
    <p>Then compile CXML using:</p>
    <pre>* (asdf:operate 'asdf:load-op :cxml)</pre>

    <p>
      You can now try the <a href="#quickstart">quick-start example</a>.
    </p>

    <a name="tests"/>
    <h2>Tests</h2>
    <p>Check out the XML and DOM testsuites:</p>
    <pre>$ export CVSROOT=:pserver:anonymous@dev.w3.org:/sources/public
$ cvs login    # password is "anonymous"
$ cvs co 2001/XML-Test-Suite/xmlconf
$ cvs co 2001/DOM-Test-Suite</pre>
    <p>Usage and expected output:</p>
    <pre>* (xmlconf:run-all-tests "/path/to/2001/XML-Test-Suite/xmlconf/")
0/556 tests failed; 1606 tests were skipped
* (domtest:run-all-tests "/path/to/2001/DOM-Test-Suite/")
0/450 tests failed; 71 tests were skipped</pre>

    <p>
      <i>fixme</i>: Add an explanation of xml/sax-tests here.
    </p>

    <p>
      <b>fixme</b> My parser does not understand the current testsuite
      anymore.&amp;nbsp; To fix this problem, revert the affected files
      manually after check-out:
    </p>

    <pre>$ cd 2001/XML-Test-Suite/xmlconf/
xmltest$ patch -p0 -R &amp;lt;/path/to/cxml/test/xmlconf-base.diff</pre>

    <p>
      The log message for the changes reads "<i>Removed unnecessary
      xml:base attribute</i>".&amp;nbsp; If I understand correctly, only
      DOM&amp;nbsp;3 parsers provide the baseURI attribute necessary for
      understanding <tt>xmlconf.xml</tt> now.&amp;nbsp; We don't have that
      yet.
    </p>

    <a name="todo"/>
    <h2>To Do</h2>
    <ul>
      <li>
        <strike>David's changes might have affected performance.&amp;nbsp; Some
        benchmarking needs to be done here.</strike> (The actual parser
        seems to be faster than xmls -- good enough for me.)
      </li>
      <li>
        DOM in general is pretty heavyweight.&amp;nbsp; There is/was a
        "simple-dom" which should be faster.&amp;nbsp; This might be worth
        reviving.
      </li>
      <li>
        <strike>For those who don't like DOM at all, it would be a very simple
        exercise to write a SAX handler for "Lisp-XML" output instead of
        DOM.</strike> (done)
      <li>
        <strike>The serializer supports only <a
        href="http://www.w3.org/TR/2001/REC-xml-c14n-20010315">Canonical
        XML</a> right now.</strike>&amp;nbsp; In the future we want support for:
        <strike>Including doctype declarations in the output</strike>
        (done), <strike>ordinary output with less character reference
        noise</strike> (done), <strike>optional indentation</strike>
        (done), user-specified encoding, etc.
      </li>
      <li>
        <strike>There are still thread-safety issues.</strike> (fixed)
      </li>
      <li>
        <strike>Validation!</strike> (done)
      </li>
      <li>
        Upgrade to DOM Level 2 for complete namespace support.
      </li>
      <li>
        Unless <tt>rune-is-character</tt> is enabled, rod hashing
        currently uses <tt>equalp</tt> hash tables, which can be very slow.
        (See <tt>%make-rod-hash-table</tt>.)
      </li>
    </ul>
    <p>
      (Compare also with Gilbert Baumann's older TODO list in
      <tt>xml-parse.lisp</tt>.)
    </p>

    <a name="using"/>
    <h2>Using CXML</h2>

    <a name="quickstart"/>
    <h3>Quick-Start Example</h3>

    <p>
      Make sure to <a href="#installation">install and load</a> cxml first.
    </p>

    <p>Create a test file called <tt>example.xml</tt>:</p>
    <pre>* <b>(with-open-file (s "example.xml" :direction :output)
    (write-string "&lt;test a='b'&gt;&lt;child/&gt;&lt;/test>" s))</b></pre>

    <p>Parse <tt>example.xml</tt> into a DOM tree (<a href="#parser">read
    more</a>):</p>
    <pre>* <b>(cxml:parse-file "example.xml" (dom:make-dom-builder))</b>
#&lt;DOM-IMPL::DOCUMENT @ #x72206172>
;; save result for later:
* <b>(defparameter *example* *)</b>
*EXAMPLE*</pre>

    <p>Inspect the DOM tree (<a href="#dom">read more</a>):</p>
    <pre>* <b>(dom:document-element *example*)</b>
#&lt;DOM-IMPL::ELEMENT test @ #x722b6ba2&gt;
* <b>(dom:tag-name (dom:document-element *example*))</b>
"test"
* <b>(dom:child-nodes (dom:document-element *example*))</b>
#(#&lt;DOM-IMPL::ELEMENT child @ #x722b6d8a&gt;)
* <b>(dom:get-attribute (dom:document-element *example*) "a")</b>
"b"</pre>

    <p>Serialize the DOM document back into a stream (<a
    href="#serialization">read more</a>):</p>
    <pre><b>(cxml:unparse-document *example* *standard-output*)</b>
&lt;test a="b"&gt;&lt;child&gt;&lt;/child>&lt;/test></pre>

    <p>As an alternative to DOM, parse into xmls-compatible list
    structure (<a href="#xmls">read more</a>):</p>
    <pre>* <b>(cxml:parse-file "example.xml" (cxml-xmls:make-xmls-builder))</b>
("test" (("a" "b")) ("child" NIL))</pre>

    <a name="parser"/>
    <h3>Parsing and Validating</h3>
    <p>
      <div class="def">Function CXML:PARSE-FILE (pathname handler &amp;key validate root)</div>
      <div class="def">Function CXML:PARSE-STREAM (stream handler &amp;key validate root)</div>
      <div class="def">Function CXML:PARSE-OCTETS (octets handler &amp;key validate root)</div>
      Parse an XML document.&amp;nbsp;
      Return values from this function depend on the SAX handler used.<br/>
      Arguments:
    </p>
    <ul>
      <li><tt>pathname</tt> -- a Common Lisp pathname</li>
      <li><tt>stream</tt> -- a Common Lisp stream with element-type
        <tt>(unsigned-byte 8)</tt></li>
      <li><tt>octets</tt> -- an <tt>(unsigned-byte 8)</tt> array</li>
      <li><tt>handler</tt> -- a SAX handler</li>
    </ul>
    <p>
      Common keyword arguments:
    </p>
    <ul>
      <li><tt>validate</tt> -- <tt>t</tt>, <tt>nil</tt>, or a DTD
        instance.&amp;nbsp; Defaults to <tt>nil</tt>.</li>
      <li><tt>root</tt> -- <tt>nil</tt> or the expected root element
        name as a <tt>rod</tt>.</li>
    </ul>
    <p>
      Arguments to <tt>validate</tt>:
    </p>
    <ul>
      <li><tt>nil</tt> -- do not validate</li>
      <li><tt>t</tt> -- assert that the document contains a DOCTYPE
        declaration and conforms to the DTD declared.</li>
      <li>a DTD instance -- assert that the document conforms to the DTD
        passed as an argument (as opposed to the DOCTYPE declaration, if
        any).
      </li>
    </ul>
    <p>
      When validating, argument <tt>root</tt> can be used to override the
      name given in the DOCTYPE declaration.&amp;nbsp; This is useful
      together with a caller-specified DTD instance.
    </p>

    <p>
      <div class="def">Function CXML:PARSE-DTD-FILE (pathname)</div>
      <div class="def">Function CXML:PARSE-DTD-STREAM (stream)</div>
      Parse <a
      href="http://www.w3.org/TR/2000/REC-xml-20001006#NT-extSubset">declarations</a>
      from a stand-alone file and return an object representing the DTD,
      suitable as an argument to <tt>validate</tt>.
    </p>
    <ul>
      <li><tt>pathname</tt> -- a Common Lisp pathname</li>
      <li><tt>stream</tt> -- a Common Lisp stream with element-type
        <tt>(unsigned-byte 8)</tt></li>
    </ul>

    <p>
      <div class="def">Function DOM:MAKE-DOM-BUILDER ()</div>
      Create a SAX handler which builds a DOM document.&amp;nbsp; Example:
    </p>
    <pre>(cxml:parse-file "test.xml" (dom:make-dom-builder))</pre>

    <a name="serialization"/>
    <h3>Serialization</h3>
    <p>
      <div class="def">Function CXML:UNPARSE-DOCUMENT (document stream &amp;rest keys)</div>
      <div class="def">Function CXML:UNPARSE-DOCUMENT-TO-OCTETS (document &amp;rest keys) => vector</div>
      Serialize a DOM document object.
    </p>
    <ul>
      <li><tt>document</tt> -- a DOM document object</li>
      <li><tt>stream</tt> -- a Common Lisp stream with element-type
        <tt>character</tt></li>
    </ul>
    <p>Keyword arguments:</p>
    <ul>
      <li>
        <tt>canonical</tt> -- canonical form, one of NIL, T, 1, 2
      </li>
      <li>
        <tt>indentation</tt> -- indentation level.  An integer or <tt>nil</tt>.
      </li>
    </ul>
    <p>
      The following <tt>canonical</tt> values are allowed:
    </p>
    <ul>
      <li>
        <tt>t</tt> or <tt>1</tt>: <a
         href="http://www.w3.org/TR/2001/REC-xml-c14n-20010315">Canonical
         XML</a>
      </li>
      <li>
        <tt>2</tt>: <a
         href="http://dev.w3.org/cvsweb/~checkout~/2001/XML-Test-Suite/xmlconf/sun/cxml.html?content-type=text/html;%20charset=iso-8859-1">Second
         Canonical Form</a>
      </li>
      <li>
        <tt>NIL</tt>: Use a more readable non-canonical representation.
      </li>
    </ul>
    <p>
      With an <tt>indentation</tt> level, pretty-print the XML by
      inserting additional whitespace.&amp;nbsp; Note that indentation
      changes the document model and should only be used if whitespace
      does not matter to the application.
    </p>
    <p>
      <tt>unparse-document-to-octets</tt> returns an <tt>(unsigned-byte
      8)</tt> array, whereas <tt>unparse-document</tt> writes
      characters.&amp;nbsp; <tt>unparse-document</tt> is useful together
      with <tt>with-output-to-string</tt>.&amp;nbsp; However, note that the
      resulting document in both cases is UTF-8 encoded, so the
      characters written by <tt>unparse-document</tt> are really UTF-8
      bytes encoded as characters.
    </p>

    <p>
      <div class="def">Function CXML:MAKE-CHARACTER-STREAM-SINK (stream &amp;rest keys) => sink</div>
      <div class="def">Function CXML:MAKE-OCTET-VECTOR-SINK (&amp;rest keys) => sink</div>
      Return a handle suitable for event-based XML serialization.
    </p>
    <p>
      These function provide the low-level mechanism used by the DOM
      serialization functions.  To serialize a document without building
      its DOM tree first, create a sink handle and call SAX functions on that
      handle.  <tt>sax:end-document</tt> returns the serialized form of
      the document described by the SAX events.
    </p>

    <p>
      <div class="def">Macro CXML:WITH-XML-OUTPUT (sink &amp;body body) => vector</div>
      <div class="def">Macro CXML:WITH-ELEMENT (qname &amp;body body) => result</div>
      <div class="def">Function CXML:ATTRIBUTE (name value) => value</div>
      <div class="def">Function CXML:TEXT (data) => data</div>
      <div class="def">Function CXML:CDATA (data) => data</div>
      Convenience syntax for event-based serialization.
    </p>
    <p>
      Example:
    </p>
    <pre>(with-xml-output (make-octet-stream-sink stream :indentation 2 :canonical nil)
  (with-element "foo"
    (attribute "xyz" "abc")
    (with-element "bar"
      (attribute "blub" "bla"))
    (text "Hi there.")))</pre>
   <p>
      Prints this to <tt>stream</tt>, which must be an
      <tt>(unsigned-byte 8)</tt> stream:
   </p>
   <pre>&amp;lt;foo xyz="abc"&amp;gt;
  &amp;lt;bar blub="bla"&amp;gt;&amp;lt;/bar&amp;gt;
  Hi there.
&amp;lt;/foo&amp;gt;</pre>
   <p>
      (Note that these functions accept both strings and rods, so we
      could write <tt>"foo"</tt> instead of <tt>#"foo"</tt> above.)
   </p>

    <a name="misc"/>
    <h3>Miscellaneous Utility Functions</h3>
    <p>
      <div class="def">Function CXML:MAKE-VALIDATOR (dtd root)</div>
      Create a SAX handler which validates against a DTD instance.&amp;nbsp;
      The document's root element must be named <tt>root</tt>.&amp;nbsp; 
      Used with <tt>dom:map-document</tt>, this validates a document
      object as if by re-reading it with a validating parser, except
      that declarations recorded in the document instance are completely
      ignored.<br/>
      Example:
    </p>
    <pre>(let ((d (parse-file "~/test.xml" (dom:make-dom-builder)))
      (x (parse-dtd-file "~/test.dtd")))
  (dom:map-document (cxml:make-validator x #"foo") d))</pre>

    <p>
      <div class="def">Function DOM:MAP-DOCUMENT (handler document &amp;key include-xmlns-attributes include-default-values)</div>
      Traverse a DOM document and call SAX functions as if an XML
      representation of the document were processed by a SAX parser.
    </p>

    <a name="xmls"/>
    <h3>XMLS Compatibility</h3>
    <p>
      Like other XML parsers written in Lisp, CXML can work with
      documents represented as list structures. The specific model
      implemented by cxml is compatible with the <a
      href="http://common-lisp.net/project/xmls/">xmls parser</a>.  Xmls
      list structures are a simpler and faster alternative to full DOM
      document trees.  They also serve as an example showing how to
      implement user-defined document models as an independent layer
      over the the base parser (c.f. <tt>xmls/xmls-compat.lisp</tt> in
      the cxml distribution).  However, note that the list structures do
      not include all information available in DOM documents and are
      sometimes more difficult to work wth since many DOM functions
      cannot be implemented on them.
    </p>
    <p>
      <div class="def">Function CXML-XMLS:MAKE-XMLS-BUILDER ()</div>
      Create a SAX handler which builds XMLS list structures.&amp;nbsp;
      Example:
    </p>
    <pre>(cxml:parse-file "test.xml" (cxml-xmls:make-xmls-builder))</pre>
    <p>
      <div class="def">Function CXML-XMLS:MAP-NODE (handler node &amp;key include-xmlns-attributes)</div>
      Traverse an XMLS document/node and call SAX functions as if an XML
      representation of the document were processed by a SAX parser.
    </p>
    <p>
      Use this function to serialize XMLS data.  For example, we could
      define a replacement for <tt>xmls:write-xml</tt> like this:
    </p>
    <pre>(defun write-xml (stream node &amp;key indent)
  (let ((sink (cxml:make-character-stream-sink
               stream :canonical nil :indentation indent)))
    (cxml-xmls:map-node sink node)))</pre>
    <p>
      <div class="def">Function CXML-XMLS:MAKE-NODE (&amp;key name ns attrs
      children) => xmls node</div>
      Build a list node of the form
      (<em>name</em>&amp;nbsp;((<em>name</em>&amp;nbsp;<em>value</em>)<em>*</em>)&amp;nbsp;<em>child*</em>).
    </p>
    <p>
      The node list's <tt>car</tt> can also be a cons of local <tt>name</tt>
      and namespace prefix <tt>ns</tt>.
      <em>fixme:</em> It is unclear to me how namespaces are meant to
      work in xmls, since xmls documentation differs from how xmls
      actually works in current releases.  Usually applications need to
      know both the namespace prefix <em>and</em> the namespace URI.  We
      currently follow the xmls <em>implementation</em> and use the
      namespace prefix instead of following its <em>documentation</em> which
      shows the URI.  We do not follow xmls in munging xmlns attribute
      values.  Attributes themselves have namespaces and it is not clear
      to me how that works in xmls.
    </p>
    <p>
      <div class="def">Accessor CXML-XMLS:NODE-NAME (node)</div>
      <div class="def">Accessor CXML-XMLS:NODE-NS (node)</div>
      <div class="def">Accessor CXML-XMLS:NODE-ATTRS (node)</div>
      <div class="def">Accessor CXML-XMLS:NODE-CHILDREN (node)</div>
      Accessors for xmls node data.
    </p>
    <p>
    </p>

    <a name="rods"/>
    <h3>Dealing with Rods</h3>
    <p>
      As explained above, the XML parser handles character encoding and
      uses 16bit strings internally.  Instead of using characters and strings
      it uses <em>runes</em> and <em>rods</em>.  This is seen as a
      feature, but can be inconvenient.
    </p>
    <ul>
      <li>
        If your Lisp supports 16 bit unicode strings, use feature
        <tt>:rune-is-character</tt> and forget about runes and rods.
        CXML will use ordinary Lisp characters and strings both
        internally and externally.
      </li>
      <li>
        If your Lisp does not support such strings and your application
        needs Unicode support, use functions defined in the
        <tt>runes</tt> package instead of ordinary string operators.
      </li>
      <li>
        If your Lisp does not support such strings and your application
        does not need Unicode support anyway, it will probably be more
        convenient to let CXML convert rods into strings automatically.
        To do that, use <tt>cxml:make-recoder</tt> to chain a special
        sax handler between the parser and your application handler.
        The recoder translates all rods using an application defined
        function, which defaults to <tt>runes:rod-string</tt>.  Although
        the actual XML parser still uses rods internally, you SAX
        handler will only see ordinary Lisp strings.
      </li>
    </ul>
    <p>
      <div class="def">Function CXML:MAKE-RECODER (chained-handler &amp;optional recoder-fn)</div>
      Return a SAX handler which passes all events on to
      <tt>chained-handler</tt> after converting all strings and rods
      using <tt>recoder-fn</tt>, a function of one argument which
      defaults to <tt>runes:rod-string</tt>.
    </p>
    <p>
      <b>Example.</b> In a Lisp which ordinarily would use octet vector rods:
    </p>
    <pre>CL-USER(14): (cxml:parse-string "&amp;lt;test/&amp;gt;" (cxml-xmls:make-xmls-builder))
(#(116 101 115 116) NIL)</pre>
    <p>
      Use a SAX recoder to get strings instead::
    </p>
    <pre>CL-USER(17): (parse-string "&amp;lt;test/&amp;gt;" (cxml:make-recoder (cxml-xmls:make-xmls-builder)))
("test" NIL)</pre>

    <a name="sax"/>
    <h2>SAX Interface</h2>
    <p>
      A SAX handler is an arbitrary objects that implements some of the
      generic functions in the SAX package.&amp;nbsp; Note that no default
      handler class is necessary, because all generic functions have default
      methods which do nothing.&amp;nbsp; SAX functions are:
      <div class="def">Function SAX:START-DOCUMENT (handler)</div>
      <div class="def">Function SAX:END-DOCUMENT (handler)</div>
      <br/>
      <div class="def">Function SAX:START-ELEMENT (handler namespace-uri local-name qname attributes)</div>
      <div class="def">Function SAX:END-ELEMENT (handler namespace-uri local-name qname)</div>
      <div class="def">Function SAX:START-PREFIX-MAPPING (handler prefix uri)</div>
      <div class="def">Function SAX:END-PREFIX-MAPPING (handler prefix)</div>
      <div class="def">Function SAX:PROCESSING-INSTRUCTION (handler target data)</div>
      <div class="def">Function SAX:COMMENT (handler data)</div>
      <div class="def">Function SAX:START-CDATA (handler)</div>
      <div class="def">Function SAX:END-CDATA (handler)</div>
      <div class="def">Function SAX:CHARACTERS (handler data)</div>
      <br/>
      <div class="def">Function SAX:START-DTD (handler name public-id system-id)</div>
      <div class="def">Function SAX:END-DTD (handler)</div>
      <div class="def">Function SAX:UNPARSED-ENTITY-DECLARATION (handler name public-id system-id notation-name)</div>
      <div class="def">Function SAX:EXTERNAL-ENTITY-DECLARATION (handler kind name public-id system-id)</div>
      <div class="def">Function SAX:INTERNAL-ENTITY-DECLARATION (handler kind name value)</div>
      <div class="def">Function SAX:NOTATION-DECLARATION (handler name public-id system-id)</div>
      <div class="def">Function SAX:ELEMENT-DECLARATION (handler name model)</div>
      <div class="def">Function SAX:ATTRIBUTE-DECLARATION (handler ename aname type default)</div>
      <br/>
      <div class="def">Accessor SAX:ATTRIBUTE-PREFIX (attribute)</div>
      <div class="def">Accessor SAX:ATTRIBUTE-NAMESPACE-URI (attribute)</div>
      <div class="def">Accessor SAX:ATTRIBUTE-LOCAL-NAME (attribute)</div>
      <div class="def">Accessor SAX:ATTRIBUTE-VALUE (attribute)</div>
      <div class="def">Accessor SAX:ATTRIBUTE-QNAME (attribute)</div>
      <div class="def">Accessor SAX:ATTRIBUTE-SPECIFIED-P (attribute)</div>
    </p>
    <p>
      The entity declaration methods are similar to Java SAX
      definitions, but parameter entities are distinguished from
      general entities not by a <tt>%</tt> prefix to the name, but by
      the <tt>kind</tt> argument, either <tt>:parameter</tt> or
      <tt>:general</tt>.
    </p>
    <p>
      The arguments to <tt>sax:element-declaration</tt> and
      <tt>sax:attribute-declaration</tt> differ significantly from their
      Java counterparts.
    </p>
    <p>
      <i>fixme</i>: For more information on these functions refer to the docstrings.
    </p>


    <a name="dom"/>
    <h2>DOM Notes</h2>
    <p>
      CXML implements the DOM Level 1 Core interfaces.&amp;nbsp; Explaining
      DOM is better left to the <a
      href="http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html">specification</a>,
      so please refer to the official W3C documents for DOM.
    </p>
    <p>
      However, there is no "standard" DOM mapping for Lisp.&amp;nbsp; DOM
      is <a
      href="http://www.w3.org/TR/REC-DOM-Level-1/idl-definitions.html">specified
      in CORBA IDL</a>, but it refrains from using object-oriented IDL
      features, allowing for a much more natural Lisp implemenation than
      the the ordinary IDL/Lisp mapping would.
    </p>
    <p>
      Differences between CXML's DOM and the direct IDL/Lisp mapping:
    </p>
    <ul>
      <li>
        DOM function names are symbols in the <tt>DOM</tt> package (not
        the <tt>OP</tt> package).
      </li>
      <li>
        DOM functions have proper required arguments, not a huge
        <tt>&amp;rest</tt> lambda list.
      </li>
      <li>
        Although most IDL interfaces are implemented as CLOS classes by
        CXML, the Lisp types of DOM objects is not documented and cannot
        be relied upon.&amp;nbsp; A node's type can be determined using
        <tt>dom:node-type</tt> instead.
      </li>
      <li>
        <tt>DOMString</tt> is mapped to <tt>rod</tt>, which is either
        an <tt>(unsigned-byte 16)</tt> array type or a string type.
      </li>
      <li>
        The IDL/Lisp mapping maps CORBA enums to Lisp keywords.&amp;nbsp;
        Unfortunately, the DOM IDL does not use enums.&amp;nbsp; Instead,
        both exception types and node types are defined integer
        constants.&amp;nbsp; CXML chooses to ignore this definition and uses
        keywords instead.
      </li>
      <li>
        DOM uses StudlyCaps.&amp;nbsp; Lisp programmers don't.&amp;nbsp; We
        insert <tt>#\-</tt> before every upper case letter preceded by a
        lower case letter and before every upper case letter which is
        followed by a lower case letter, but preceded by a capital
        letter.&amp;nbsp; This algorithms leads to the natural Lisp spelling
        of DOM function names.
      </li>
      <li>
        Implementation note: DOM's <tt>NodeList</tt> does not
        necessarily map to a native "sequence" type.&amp;nbsp; (For example,
        node lists are objects in Java, not arrays.)&amp;nbsp;
        <tt>NodeList</tt> is specified to reflect changes done after a
        node list was created, so node lists cannot be Lisp lists.&amp;nbsp;
        (A node list could be implemented as a CLOS object pointing to
        said list though.)&amp;nbsp; Instead, CXML currently implements node
        lists as adjustable vectors.&amp;nbsp; Note that code which relies on
        this implementation and uses Lisp sequence functions
        instead of sticking to <tt>dom:item</tt> and <tt>dom:length</tt>
        is not portable.&amp;nbsp; As a compromise, you can use our
        extensions <tt>dom:map-node-list</tt> or
        <tt>dom:do-node-list</tt>, which can be implemented portably.
      </li>
    </ul>
    <p>Example:</p>
    <pre>XML(97): (dom:node-type
          (dom:document-element
           (cxml:parse-file "~/test.xml" (dom:make-dom-builder))))
:ELEMENT</pre>
  </body>
</html>
